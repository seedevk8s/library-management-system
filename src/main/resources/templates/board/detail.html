<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
      th:replace="~{common/layout :: layout(~{::title}, ~{::content}, ~{::css}, ~{::scripts})}">

<head>
    <meta charset="UTF-8">
    <title>게시글 상세</title>

    <!--게시글 상세 페이지 전용 스타일 (layout.html의 <head>에 삽입됨)-->
    <th:block th:fragment="css">
        <style>
            /* === 게시글 상세 컨테이너 === */
            .board-detail {
                max-width: 900px;       /* 최대 너비 900px로 제한 */
                margin: 0 auto;
                background-color: white;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,1);
            }
            /* ===게시글 헤더 영역 ===*/
            .board-header {
                padding: 30px;
                border-bottom: 2px solid #e9ecef;
            }
            .board-title {
                font-size: 28px;
                font-weight: bold;
                color: #333;
                margin-bottom: 20px;
                line-height: 1.4;
            }
            /* === 게시글 메타 정보 컨테이너 ===*/
            .board-meta {
                display: flex;
                justify-content: space-between;     /* 양쪽 끝으로 배치 */
                align-items: center;
                flex-wrap: wrap;                    /* 화면이 좁으면 줄바꿈 */
                gap: 15px;
                color: #6c757d;
                font-size: 14px;
            }
            /* 메타 정보 좌측 영역 (카테고리, 작성자, 작성일) */
            .meta-left {
                display: flex;
                gap: 20px;
                align-items: center;
            }
            /* 메타 정보 우측 영역 (조회수, 좋아요, 댓글 수) */
            .meta-right {
                display:flex;
                gap: 15px;
                align-items: center;
            }
            /* 개별 메타 정보 아이템 (아이콘 + 텍스트) */
            .meta-item {
                display:flex;
                align-items: center;
                gap: 5px;
            }

            /* 메타 정보 아이콘 색상 */
            .meta-item i {
                color: #007bff;
            }

            /* === 카테고리 배치 === */
            .category-badge {
                display: inline-block;
                padding: 4px 12px;
                border-radius: 12px;
                font-size: 12px;
                font-weight: 500;           /* 중간 굵기 글씨 */
            }

            /* 공지사항 카테고리 - 빨간색 */
            .category-badge.NOTICE {
                background-color: #dc3545;
                color: white;
            }
            /* 자유게시판 카테로그 - 청록색 */
            .category-badge.FREE {
                background-color: #28a745;
                color: white;
            }
            /* 질문답변 카테로그 - 노란색 */
            .category-badge.QNA {
                background-color: #ffc107;
                color: #333;
            }
            /* 리뷰 카테로그 - 연두색 */
            .category-badge.REVIEW {
                background-color: #17a2b8;
                color: white;
            }

            .board-content {
                padding: 30px;
                min-height: 300px;      /* 최소 높이 (짧은 글도 일정 공간 확보) */
                line-height: 1.0        /* 줄 간격 (가독성 향상) */
                color: #333;
                font-size: 16px;
                border-bottom: 2px solid #e9ecef;
            }

            .board-content p {
                margin-bottom: 1em;
            }

            /* === 게시글 푸터 (버튼 영역) === */
            .board-footer {
                padding: 20px 30px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .btn-group {
                display: flex;
                gap: 10px;
            }

            /* === 좋아요 버튼 스타일 === */
            .like-button-container {
                display: flex;
                align-items: center;
                gap: 15px;              /* 좋아요 버튼과 다른 버튼들 사이 간격 */
            }

            .like-button {
                display: flex;
                align-items: center;
                gap: 8px;               /* 하트 아이콘과 숫자 사이 간격 */
                padding: 10px 20px;
                border: 2px solid #dee2e6;
                background-color: white;
                border-radius: 25px;    /* 둥근 모서리 */
                cursor: pointer;
                transition: all 0.3s ease;  /* 부드러운 애니메이션 */
                font-size: 16px;
                font-weight: 500;
            }

            .like-button i {
                font-size: 18px;
                transition: all 0.3s ease;
            }

            /* 좋아요 안 누른 상태 (기본) */
            .like-button:not(.liked) {
                color: #6c757d;         /* 회색 텍스트 */
            }

            .like-button:not(.liked) i {
                color: #6c757d;         /* 회색 하트 */
            }

            .like-button:not(.liked):hover {
                border-color: #ff6b6b;
                color: #ff6b6b;
                transform: scale(1.05);  /* 살짝 확대 */
            }

            .like-button:not(.liked):hover i {
                color: #ff6b6b;
            }

            /* 좋아요 누른 상태 */
            .like-button.liked {
                border-color: #ff6b6b;
                background-color: #fff5f5;  /* 연한 빨간색 배경 */
                color: #ff6b6b;
            }

            .like-button.liked i {
                color: #ff6b6b;         /* 빨간 하트 */
                animation: heartbeat 0.3s ease;  /* 하트 애니메이션 */
            }

            .like-button.liked:hover {
                background-color: #ffe0e0;
                transform: scale(1.05);
            }

            /* 하트 클릭 애니메이션 */
            @keyframes heartbeat {
                0% { transform: scale(1); }
                50% { transform: scale(1.3); }
                100% { transform: scale(1); }
            }

            /* 로그인 필요 상태 (비활성화) */
            .like-button:disabled {
                cursor: not-allowed;
                opacity: 0.6;
            }

            /* alert 기본 스타일 */
            .alert {
                padding: 12px 16px;
                border: 1px solid;
                border-radius: 4px;
            }

            /* === 좋아요 버튼 스타일 === */
            .like-button-container {
                display: flex;
                align-items: center;
                gap: 15px;              /* 좋아요 버튼과 다른 버튼들 사이 간격 */
            }

            .like-button {
                display: flex;
                align-items: center;
                gap: 8px;               /* 하트 아이콘과 숫자 사이 간격 */
                padding: 10px 20px;
                border: 2px solid #dee2e6;
                background-color: white;
                border-radius: 25px;    /* 둥근 모서리 */
                cursor: pointer;
                transition: all 0.3s ease;  /* 부드러운 애니메이션 */
                font-size: 16px;
                font-weight: 500;
            }

            .like-button i {
                font-size: 18px;
                transition: all 0.3s ease;
            }

            /* 좋아요 안 누른 상태 (기본) */
            .like-button:not(.liked) {
                color: #6c757d;         /* 회색 텍스트 */
            }

            .like-button:not(.liked) i {
                color: #6c757d;         /* 회색 하트 */
            }

            .like-button:not(.liked):hover {
                border-color: #ff6b6b;
                color: #ff6b6b;
                transform: scale(1.05);  /* 살짝 확대 */
            }

            .like-button:not(.liked):hover i {
                color: #ff6b6b;
            }

            /* 좋아요 누른 상태 */
            .like-button.liked {
                border-color: #ff6b6b;
                background-color: #fff5f5;  /* 연한 빨간색 배경 */
                color: #ff6b6b;
            }

            .like-button.liked i {
                color: #ff6b6b;         /* 빨간 하트 */
                animation: heartbeat 0.3s ease;  /* 하트 애니메이션 */
            }

            .like-button.liked:hover {
                background-color: #ffe0e0;
                transform: scale(1.05);
            }

            /* 하트 클릭 애니메이션 */
            @keyframes heartbeat {
                0% { transform: scale(1); }
                50% { transform: scale(1.3); }
                100% { transform: scale(1); }
            }

            /* 로그인 필요 상태 (비활성화) */
            .like-button:disabled {
                cursor: not-allowed;
                opacity: 0.6;
            }

            /* 첨부 파일 영역 스타일 */
            .board-files {  /* 첨부파일 컨테이너 */
                padding: 30px;
                border-bottom: 2px solid #e9ecef;
                background-color: #f8f9fa;
            }
            .files-header { /* 첨부파일 헤더 */
                font-size: 18px;
                font-weight: bold;
                color: #333;
                margin-bottom: 15px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .files-header i {
                color: #007bff;
            }

            .file-list {    /* 파일 목록 */
                list-style: none;
                padding: 0;
                margin: 0;
            }

            .file-item {  /* 개별 파일 아이템 */
                display: flex;
                align-items: center;
                padding: 12px 15px;
                margin-bottom: 8px;
                background-color: white;
                border: 1px solid #dee2e6;
                border-radius: 6px;
                transition: all 0.2s ease;
            }

            .file-item:hover {
                background-color: #f8f9fa;
                border-color: #007bff;
                transform: translateX(5px); /*오른쪽으로 5px 이동*/
            }

            .file-item:last-child {
                margin-bottom: 0;
            }

            .file-icon {
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;            /* 세로 중앙 정렬 */
                justify-content: center;        /* 가로 중앙 정렬 */
                border-radius: 8px;
                margin-right: 12px;
                font-size: 20px;
            }

            .file-icon.IMAGE {
                background-color: #e3f2fd;
                color: #1976d2;
            }
            .file-icon.DOCUMENT {
                background-color: #fff3e0;
                color: #f57c00;
            }
            .file-icon.ARCHIVE {
                background-color: #f3e5f5;
                color: #7b1fa2;
            }
            .file-icon.OTHER {
                background-color: #e0e0e0;
                color: #616161;
            }
            .file-info {
                flex: 1;                /* 남은 공간 채우기 */
                display: flex;
                flex-direction: column;     /* 세로 방향 배치 */
                gap: 4px;
            }
            .file-name {
                font-size: 15px;
                font-weight: 500;
                color: #333;
                word-break: break-all;      /* 긴 파일명 줄바꿈 */
            }
            .file-meta {
                display:flex;
                gap: 12px;
                font-size: 13px;
                color: #6c757d;
            }
            .file-meta i {
                margin-right: 4px;
                font-size: 12px;
            }
            .file-download-btn {
                padding: 8px 16px;
                background-color: #007bff;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                text-decoration: none;
                transition: background-color 0.2s ease;
                white-space: nowrap;            /* 텍스트 줄바꿈 방지 */
            }
            .file-download-btn:hover {
                background-color: #0056b3;
                text-decoration: none;
            }
            .file-download-btn i {
                margin-right: 4px;
            }

            /* === 댓글 섹션 스타일 === */

            /* 댓글 섹션 전체 컨테이너 */
            .comments-section {
                padding: 30px;                      /* 내부 여백 30px */
                background-color: #f8f9fa;          /* 연한 회색 배경 (게시글 본문과 구분) */
            }

            /* 댓글 헤더 영역 (제목 + 댓글 개수) */
            .comments-header {
                margin-bottom: 20px;                /* 아래 여백 20px (댓글 작성 폼과 간격) */
                padding-bottom: 15px;               /* 내부 하단 여백 15px */
                border-bottom: 2px solid #dee2e6;   /* 하단 경계선 2px (헤더와 내용 구분) */
            }

            .comments-header h3 {
                font-size: 20px;                    /* 제목 크기 20px */
                font-weight: bold;                  /* 굵은 글씨 */
                color: #333;                        /* 진한 회색 텍스트 */
                margin: 0;                          /* 기본 여백 제거 */
            }

            .comments-header i {
                color: #007bff;                     /* 아이콘 파란색 (브랜드 컬러) */
                margin-right: 8px;                  /* 아이콘과 텍스트 사이 간격 8px */
            }

            /* === 댓글 작성 폼 (로그인 사용자용) === */
            .comment-write {
                background-color: white;            /* 흰색 배경 */
                padding: 20px;                      /* 내부 여백 20px */
                border-radius: 8px;                 /* 모서리 둥글게 8px */
                border: 1px solid #dee2e6;          /* 연한 회색 테두리 1px */
                margin-bottom: 20px;                /* 아래 여백 20px (댓글 목록과 간격) */
            }

            .comment-write textarea {
                width: 100%;                        /* 가로 너비 100% (부모 요소에 맞춤) */
                padding: 12px;                      /* 내부 여백 12px */
                border: 1px solid #dee2e6;          /* 연한 회색 테두리 1px */
                border-radius: 4px;                 /* 모서리 둥글게 4px */
                resize: vertical;                   /* 세로 방향으로만 크기 조절 가능 */
                font-size: 14px;                    /* 글자 크기 14px */
                font-family: inherit;               /* 부모 요소의 글꼴 상속 */
                margin-bottom: 10px;                /* 아래 여백 10px (버튼과 간격) */
            }

            .comment-write textarea:focus {
                outline: none;                      /* 포커스 시 기본 외곽선 제거 */
                border-color: #007bff;              /* 포커스 시 테두리 파란색으로 변경 */
            }

            .comment-write button {
                float: right;                       /* 버튼을 오른쪽으로 정렬 */
            }

            /* === 로그인 안내 (비로그인 사용자용) === */
            .comment-login-required {
                background-color: white;            /* 흰색 배경 */
                padding: 30px;                      /* 내부 여백 30px */
                border-radius: 8px;                 /* 모서리 둥글게 8px */
                border: 1px solid #dee2e6;          /* 연한 회색 테두리 1px */
                text-align: center;                 /* 텍스트 가운데 정렬 */
                color: #6c757d;                     /* 중간 회색 텍스트 */
                margin-bottom: 20px;                /* 아래 여백 20px */
            }

            .comment-login-required i {
                font-size: 40px;                    /* 아이콘 크기 40px (강조) */
                margin-bottom: 15px;                /* 아래 여백 15px (텍스트와 간격) */
                color: #adb5bd;                     /* 연한 회색 아이콘 */
            }

            .comment-login-required p {
                margin: 0;                          /* 기본 여백 제거 */
                font-size: 16px;                    /* 글자 크기 16px */
            }

            .comment-login-required a {
                color: #007bff;                     /* 링크 파란색 */
                text-decoration: none;              /* 밑줄 제거 */
                font-weight: 500;                   /* 중간 굵기 글씨 */
            }

            .comment-login-required a:hover {
                text-decoration: underline;         /* 마우스 오버 시 밑줄 표시 */
            }

            /* === 댓글 목록 컨테이너 === */
            .comment-list {
                display: flex;                      /* Flexbox 레이아웃 사용 */
                flex-direction: column;             /* 세로 방향 배치 */
                gap: 15px;                          /* 댓글 아이템 간 간격 15px */
            }

            /* === 개별 댓글 아이템 === */
            .comment-item {
                background-color: white;            /* 흰색 배경 */
                padding: 20px;                      /* 내부 여백 20px */
                border-radius: 8px;                 /* 모서리 둥글게 8px */
                border: 1px solid #dee2e6;          /* 연한 회색 테두리 1px */
            }

            /* 댓글 헤더 (작성자 정보 + 작업 버튼) */
            .comment-header {
                display: flex;                      /* Flexbox 레이아웃 사용 */
                justify-content: space-between;     /* 양쪽 끝으로 배치 (작성자 왼쪽, 버튼 오른쪽) */
                align-items: center;                /* 세로 중앙 정렬 */
                margin-bottom: 12px;                /* 아래 여백 12px (댓글 내용과 간격) */
            }

            /* 작성자 정보 영역 (아이콘 + 이름 + 날짜) */
            .comment-author {
                display: flex;                      /* Flexbox 레이아웃 사용 */
                align-items: center;                /* 세로 중앙 정렬 */
                gap: 10px;                          /* 요소 간 간격 10px */
            }

            .comment-author i {
                color: #6c757d;                     /* 아이콘 회색 */
            }

            .comment-author-name {
                font-weight: 600;                   /* 작성자 이름 강조 (굵게) */
                color: #333;                        /* 진한 회색 텍스트 */
            }

            .comment-date {
                font-size: 13px;                    /* 작은 글자 크기 13px */
                color: #6c757d;                     /* 중간 회색 텍스트 */
            }

            /* 댓글 작업 버튼 그룹 (수정/삭제) */
            .comment-actions {
                display: flex;                      /* Flexbox 레이아웃 사용 */
                gap: 8px;                           /* 버튼 간 간격 8px */
            }

            .comment-actions button {
                padding: 4px 12px;                  /* 버튼 내부 여백 (상하 4px, 좌우 12px) */
                font-size: 13px;                    /* 작은 글자 크기 13px */
                border: none;                       /* 테두리 제거 */
                border-radius: 4px;                 /* 모서리 둥글게 4px */
                cursor: pointer;                    /* 마우스 커서 포인터로 변경 */
                transition: all 0.2s;               /* 모든 속성 0.2초 애니메이션 */
            }

            /* 수정 버튼 스타일 */
            .comment-edit-btn {
                background-color: #007bff;          /* 파란색 배경 */
                color: white;                       /* 흰색 텍스트 */
            }

            .comment-edit-btn:hover {
                background-color: #0056b3;          /* 마우스 오버 시 진한 파란색 */
            }

            /* 삭제 버튼 스타일 */
            .comment-delete-btn {
                background-color: #dc3545;          /* 빨간색 배경 */
                color: white;                       /* 흰색 텍스트 */
            }

            .comment-delete-btn:hover {
                background-color: #c82333;          /* 마우스 오버 시 진한 빨간색 */
            }

            /* 댓글 내용 */
            .comment-content {
                color: #333;                        /* 진한 회색 텍스트 */
                font-size: 15px;                    /* 글자 크기 15px */
                line-height: 1.6;                   /* 줄 간격 1.6배 (가독성 향상) */
                white-space: pre-wrap;              /* 줄바꿈 및 공백 유지 */
                word-wrap: break-word;              /* 긴 단어 자동 줄바꿈 */
            }

            /* === 댓글 수정 폼 === */
            .comment-edit-form {
                margin-top: 12px;                   /* 위쪽 여백 12px (댓글 내용과 간격) */
            }

            .comment-edit-form textarea {
                width: 100%;                        /* 가로 너비 100% */
                padding: 12px;                      /* 내부 여백 12px */
                border: 1px solid #dee2e6;          /* 연한 회색 테두리 1px */
                border-radius: 4px;                 /* 모서리 둥글게 4px */
                resize: vertical;                   /* 세로 방향으로만 크기 조절 가능 */
                font-size: 14px;                    /* 글자 크기 14px */
                font-family: inherit;               /* 부모 요소의 글꼴 상속 */
                margin-bottom: 10px;                /* 아래 여백 10px (버튼과 간격) */
            }

            .comment-edit-form textarea:focus {
                outline: none;                      /* 포커스 시 기본 외곽선 제거 */
                border-color: #007bff;              /* 포커스 시 테두리 파란색으로 변경 */
            }

            /* 수정 폼 버튼 그룹 (저장/취소) */
            .comment-edit-actions {
                display: flex;                      /* Flexbox 레이아웃 사용 */
                gap: 8px;                           /* 버튼 간 간격 8px */
                justify-content: flex-end;          /* 버튼을 오른쪽으로 정렬 */
            }

            .comment-edit-actions button {
                padding: 6px 16px;                  /* 버튼 내부 여백 (상하 6px, 좌우 16px) */
                font-size: 14px;                    /* 글자 크기 14px */
                border: none;                       /* 테두리 제거 */
                border-radius: 4px;                 /* 모서리 둥글게 4px */
                cursor: pointer;                    /* 마우스 커서 포인터로 변경 */
            }

            /* 저장 버튼 스타일 */
            .comment-save-btn {
                background-color: #28a745;          /* 초록색 배경 */
                color: white;                       /* 흰색 텍스트 */
            }

            .comment-save-btn:hover {
                background-color: #218838;          /* 마우스 오버 시 진한 초록색 */
            }

            /* 취소 버튼 스타일 */
            .comment-cancel-btn {
                background-color: #6c757d;          /* 회색 배경 */
                color: white;                       /* 흰색 텍스트 */
            }

            .comment-cancel-btn:hover {
                background-color: #5a6268;          /* 마우스 오버 시 진한 회색 */
            }

            /* === 댓글 없음 안내 메시지 === */
            .no-comments {
                text-align: center;                 /* 텍스트 가운데 정렬 */
                padding: 40px;                      /* 내부 여백 40px */
                color: #6c757d;                     /* 중간 회색 텍스트 */
                background-color: white;            /* 흰색 배경 */
                border-radius: 8px;                 /* 모서리 둥글게 8px */
                border: 1px solid #dee2e6;          /* 연한 회색 테두리 1px */
            }

            .no-comments i {
                font-size: 48px;                    /* 큰 아이콘 크기 48px */
                margin-bottom: 15px;                /* 아래 여백 15px (텍스트와 간격) */
                color: #adb5bd;                     /* 연한 회색 아이콘 */
            }

            .no-comments p {
                margin: 0;                          /* 기본 여백 제거 */
                font-size: 16px;                    /* 글자 크기 16px */
            }
        </style>
    </th:block>
</head>
<body>
<!--메인 컨텐츠 영역 (layout.html의 <main>에 삽입됨)-->
<th:block th:fragment="content">
    <!--성공 메시지 (게시글 작성 완료)-->
    <div th:if="${success}" class="alert alert-success alert-dismissible fade show" role="alert"
            style="margin: 20px auto; max-width: 900px; margin-bottom: 20px;">
        <strong>✅ 성공</strong>
        <span th:text="${success}"></span>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    </div>

    <div class="board-detail">
        <!--게시글 헤더 영역-->
        <div class="board-header">
            <h1 class="board-title" th:text="${board.title}">게시글 제목</h1>

            <!--게시글 메타 정보 영역-->
            <div class="board-meta">
                <!--좌측 정보 : 카테고리, 작성자, 작성일-->
                <div class="meta-left">
                    <span class="category-badge"
                          th:classappend="${board.category.name()}"
                          th:text="${board.category.displayName}">
                        카테고리
                    </span>
                    <span class="meta-item">
                        <i class="fas fa-user"></i>
                        <span th:text="${board.authorName}">작성자</span>
                    </span>
                    <span class="meta-item">
                        <i class="fas fa-calendar"></i>
                        <span th:text="${#temporals.format(board.createdAt, 'yyyy-MM-dd HH:mm')}">2025-10-14 16:00</span>
                    </span>

                </div>

                <!--우측 정보 : 조회수, 좋아요 수, 댓글 수-->
                <div class="meta-right">
                    <!--조회수 표시-->
                    <span class="meta-item">
                        <i class="fas fa-eye"></i>
                        <span th:text="${board.viewCount}">0</span>
                    </span>

                    <!--좋아요 표시-->
                    <span class="meta-item">
                        <i class="fas fa-heart"></i>
                        <span th:text="${board.likeCount}">0</span>
                    </span>

                    <!--댓글 수 표시 (추현 구현 예정)-->
                    <span class="meta-item">
                        <i class="fas fa-comment"></i>
                        <span th:text="${board.commentCount}">0</span>
                    </span>

                </div>
            </div>

        </div>

        <!-- === 게시글 본문 영역 === -->
        <div class="board-content">
            <div style="white-space: pre-wrap; word-wrap: break-word;" th:text="${board.content}">
                게시글 내용이 여기에 표시됩니다.
            </div>
        </div>

        <!-- === 첨부 파일 영역 ===
            첨부파일이 존재할 경우에만 표시.  #lists: Thymeleaf 리스트 유틸리티 객체 .isEmpty()
        -->
        <div class="board-files" th:if="${not #lists.isEmpty(board.files)}">
            <div class="files-header">
                <i class="fas fa-paperclip"></i>    <!--클립 아이콘-->
                <span>첨부파일(<span th:text="${#lists.size(board.files)}">0</span>개)</span>
            </div>
            <!--파일 목록(순서 없는 리스트)-->
            <ul class="file-list">
                <li class="file-item" th:each="file : ${board.files}">
                    <!--파일 타입별 아이콘 표시-->
                    <div class="file-icon" th:classappend="${file.getFileType()}">
                        <i class="fas" th:classappend="${file.getFileIconClass()}"></i>
                    </div>
                    <!--파일 정보 영역(파일명, 메타 정보)-->
                    <div class="file-info">
                        <div class="file-name" th:text="${file.originalFilename}">파일명.jpg</div>
                        <div class="file-meta">
                            <span><i class="fas fa-hdd"></i><span th:text="${file.getFormattedFileSize()}">1.1MB</span></span>
                            <span><i class="fas fa-download"></i><span th:text="${file.downloadCount}">0</span>회</span>
                        </div>
                    </div>
                    <!--파일 다운로드 버튼 (GET /files/download/{id})-->
                    <a th:href="@{/files/download/{id}(id=${file.id})}"
                        class="file-download-btn">
                        <i class="fas fa-download"></i> 다운로드
                    </a>
                </li>
            </ul>
        </div>


        <!-- === 게시글 푸터 (버튼 영역) === -->
        <div class="board-footer">
            <!-- 좌측: 목록 버튼 + 좋아요 버튼 -->
            <div class="like-button-container">
                <a th:href="@{/boards(page=${page})}" class="btn btn-outline">
                    <i class="fas fa-list"></i> 목록
                </a>

                <!-- 좋아요 버튼 (로그인 사용자용) -->
                <button type="button"
                        class="like-button"
                        id="likeButton"
                        th:classappend="${board.userLiked} ? 'liked' : ''"
                        th:data-board-id="${board.id}"
                        th:data-liked="${board.userLiked}"
                        sec:authorize="isAuthenticated()">
                    <i th:class="${board.userLiked} ? 'fas fa-heart' : 'far fa-heart'"></i>
                    <span id="likeCount" th:text="${board.likeCount}">0</span>
                </button>

                <!-- 비로그인 사용자용 좋아요 버튼 (비활성화) -->
                <button type="button"
                        class="like-button"
                        disabled
                        sec:authorize="!isAuthenticated()">
                    <i class="far fa-heart"></i>
                    <span th:text="${board.likeCount}">0</span>
                </button>
            </div>

            <!-- 우측: 수정/삭제 버튼 (작성자만 표시) -->
            <div class="btn-group" sec:authorize="isAuthenticated()"
                    th:if="${#authentication.name == board.authorEmail}">
                <!--로그인한 사용자가 작성자일 경우에만 수정/삭제 버튼 표시 -->
                <a th:href="@{/boards/{id}/edit(id=${board.id})}" class="btn btn-outline">
                    <i class="fas fa-edit"></i> 수정
                </a>
                <button type="button" class="btn btn-danger" onclick="deleteBoard()">
                    <i class="fas fa-trash-alt"></i> 삭제
                </button>

            </div>
        </div>

        <!-- === 댓글 섹션 === -->
        <!--
            구현 순서 1: HTML 구조 작성
                - 댓글 헤더 (제목 + 개수 표시)
                - 댓글 작성 폼 (로그인 사용자용)
                - 로그인 안내 (비로그인 사용자용)
                - 댓글 목록 컨테이너 (JavaScript로 채워질 공간)
        -->
        <div class="comments-section">
            <!--
                구현 순서 2: 댓글 헤더 영역
                    - 댓글 아이콘과 제목 표시
                    - commentCount: JavaScript에서 실시간으로 업데이트할 요소
            -->
            <div class="comments-header">
                <h3>
                    <i class="fas fa-comments"></i>
                    댓글 <span id="commentCount">0</span>개
                </h3>
            </div>

            <!--
                구현 순서 3: 댓글 작성 폼 (로그인한 사용자만 표시)
                    - sec:authorize="isAuthenticated()": Spring Security로 로그인 여부 확인
                    - commentContent: 사용자가 입력할 textarea (JavaScript에서 접근)
                    - createCommentBtn: 작성 버튼 (JavaScript 이벤트 리스너 등록 대상)
            -->
            <div class="comment-write" sec:authorize="isAuthenticated()">
                <textarea id="commentContent"
                          placeholder="댓글을 입력하세요..."
                          rows="3"></textarea>
                <button type="button" class="btn btn-primary" id="createCommentBtn">
                    <i class="fas fa-paper-plane"></i> 댓글 작성
                </button>
            </div>

            <!--
                구현 순서 4: 로그인 안내 메시지 (비로그인 사용자)
                    - sec:authorize="!isAuthenticated()": 로그인하지 않은 경우에만 표시
                    - 로그인 페이지로 이동하는 링크 제공
            -->
            <div class="comment-login-required" sec:authorize="!isAuthenticated()">
                <i class="fas fa-lock"></i>
                <p>댓글을 작성하려면 <a th:href="@{/auth/login}">로그인</a>이 필요합니다.</p>
            </div>

            <!--
                구현 순서 5: 댓글 목록 컨테이너
                    - id="commentList": JavaScript에서 동적으로 댓글 HTML을 삽입할 대상
                    - 페이지 로드 시 loadComments() 함수가 REST API를 호출하여 댓글을 가져옴
                    - renderComments() 함수가 이 영역에 댓글 HTML을 생성하여 삽입
            -->
            <div id="commentList" class="comment-list">
                <!-- JavaScript로 동적으로 댓글이 추가됩니다 -->
            </div>
        </div>
    </div>
</th:block>

<!--게시글 상세 페이지 전용 JavaScript (layout.html의 </body> 직전에 삽입됨)-->
<th:block th:fragment="scripts">
    <script th:inline="javascript">
        /*<![CDATA[*/

        /* ========================================
           구현 순서 6: 전역 변수 선언 및 초기화
           ======================================== */

        // 6-1. Thymeleaf 인라인 표현식으로 서버 데이터를 JavaScript 변수로 전달
        //      [[${expression}]]: Thymeleaf가 서버 변수를 JavaScript 코드로 렌더링
        const boardId = [[${board.id}]];  // 게시글 ID (예: 123)
        const currentUserEmail = [[${#authentication.name}]] || null;  // 현재 로그인한 사용자 이메일 (비로그인 시 null)

        // 6-2. CSRF 토큰 가져오기
        //      layout.html의 <head>에 있는 메타 태그에서 CSRF 토큰 정보 읽어오기
        //      Spring Security의 CSRF 보호 기능을 위한 토큰
        const csrfToken = document.querySelector('meta[name="_csrf"]').content;
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]').content;

        /* ========================================
           구현 순서 7: 페이지 로드 이벤트 처리
           ======================================== */

        // 7-1. DOMContentLoaded: HTML 문서가 완전히 로드되고 DOM 트리가 완성된 후 실행
        //      이미지 등의 리소스 로딩을 기다리지 않아 빠르게 실행됨
        document.addEventListener('DOMContentLoaded', function() {
            // 7-2. 페이지 로드 즉시 댓글 목록 조회
            loadComments();  // 댓글 목록 불러오기

            // 7-3. 댓글 작성 버튼에 이벤트 리스너 등록
            const createCommentBtn = document.getElementById('createCommentBtn');  // 댓글 작성 버튼 요소 가져오기
            if (createCommentBtn) {  // 버튼이 존재하는지 확인 (로그인한 사용자만 버튼이 렌더링됨)
                createCommentBtn.addEventListener('click', createComment);  // 클릭 이벤트에 createComment 함수 연결
            }
        });



        /* ========================================
           구현 순서 8: 댓글 목록 조회 (GET 요청)
           ======================================== */

        /*
            8. 댓글 목록 조회 함수
                - GET /api/comments/boards/{boardId} 호출
                - 성공 시 화면에 댓글 목록 렌더링
        */
        function loadComments() {
            // 8-1. Fetch API로 REST API 호출 (GET 요청)
            fetch(`/api/comments/boards/${boardId}`)  // 템플릿 리터럴로 URL 생성
                .then(response => response.json())  // 8-2. JSON 응답을 JavaScript 객체로 변환
                .then(comments => {  // 8-3. 변환된 댓글 배열 받기
                    renderComments(comments);  // 8-4. 댓글 목록 화면에 표시
                })
                .catch(error => {  // 8-5. 에러 발생 시 처리
                    console.error('댓글 로드 실패:', error);
                    alert('댓글을 불러오는데 실패했습니다.');
                });
        }



        /* ========================================
           구현 순서 9: 댓글 목록 렌더링 (화면 표시)
           ======================================== */

        /*
            9. 댓글 목록 렌더링 함수
                - 댓글 배열을 받아서 HTML로 변환하여 화면에 표시
        */
        function renderComments(comments) {
            // 9-1. DOM 요소 가져오기
            const commentList = document.getElementById('commentList');  // 댓글 목록 컨테이너
            const commentCount = document.getElementById('commentCount');  // 댓글 개수 표시 영역

            // 9-2. 댓글 개수 업데이트
            commentCount.textContent = comments.length;

            // 9-3. 댓글이 없는 경우 안내 메시지 표시
            if (comments.length === 0) {
                commentList.innerHTML = `
                    <div class="no-comments">
                        <i class="fas fa-comments"></i>
                        <p>첫 댓글을 작성해보세요!</p>
                    </div>
                `;
                return;  // 함수 종료
            }

            // 9-4. 댓글 목록 HTML 생성
            //      - Array.map(): 각 댓글 객체를 HTML 문자열로 변환
            //      - Array.join(''): HTML 문자열 배열을 하나의 문자열로 결합
            commentList.innerHTML = comments.map(comment => createCommentHTML(comment)).join('');
        }



        /* ========================================
           구현 순서 10: 개별 댓글 HTML 생성
           ======================================== */

        /*
            10. 개별 댓글 HTML 생성 함수
                - 댓글 객체를 받아서 HTML 문자열로 변환
        */
        function createCommentHTML(comment) {
            // 10-1. 날짜 포맷팅 (ISO 8601 형식을 보기 좋게 변환)
            const date = new Date(comment.createdAt);  // ISO 8601 문자열을 JavaScript Date 객체로 변환
            const formattedDate = date.toLocaleString('ko-KR', {  // 한국 로케일로 날짜/시간 포맷팅
                year: 'numeric',  // 연도: 4자리 숫자 (예: 2025)
                month: '2-digit',  // 월: 2자리 숫자 (예: 01, 10)
                day: '2-digit',  // 일: 2자리 숫자 (예: 01, 20)
                hour: '2-digit',  // 시: 2자리 숫자 (예: 09, 14)
                minute: '2-digit'  // 분: 2자리 숫자 (예: 05, 30)
            });

            // 10-2. 현재 사용자가 댓글 작성자인지 확인
            //       현재 로그인한 사용자와 댓글 작성자가 같으면 true (수정/삭제 버튼 표시용)
            const isAuthor = currentUserEmail === comment.authorEmail;

            // 10-3. 댓글 HTML 생성 (템플릿 리터럴 사용)
            return `
                <!-- 10-3-1. 댓글 컨테이너 (고유 ID로 개별 댓글 식별) -->
                <div class="comment-item" id="comment-${comment.id}">
                    <!-- 10-3-2. 댓글 헤더: 작성자 정보 및 작업 버튼 -->
                    <div class="comment-header">
                        <!-- 10-3-3. 작성자 정보: 아이콘, 이름, 작성일시 -->
                        <div class="comment-author">
                            <i class="fas fa-user-circle"></i>
                            <span class="comment-author-name">${escapeHtml(comment.authorName)}</span>
                            <span class="comment-date">${formattedDate}</span>
                        </div>
                        <!-- 10-3-4. 작업 버튼: 작성자 본인일 경우에만 표시 (삼항 연산자 사용) -->
                        ${isAuthor ? `
                            <div class="comment-actions">
                                <!-- 수정 버튼: 클릭 시 editComment() 함수 호출 -->
                                <button class="comment-edit-btn" onclick="editComment(${comment.id})">
                                    <i class="fas fa-edit"></i> 수정
                                </button>
                                <!-- 삭제 버튼: 클릭 시 deleteComment() 함수 호출 -->
                                <button class="comment-delete-btn" onclick="deleteComment(${comment.id})">
                                    <i class="fas fa-trash"></i> 삭제
                                </button>
                            </div>
                        ` : ''}
                    </div>
                    <!-- 10-3-5. 댓글 내용: XSS 방지를 위해 escapeHtml 처리, 고유 ID로 수정 시 타겟팅 -->
                    <div class="comment-content" id="comment-content-${comment.id}">
                        ${escapeHtml(comment.content)}
                    </div>
                </div>
            `;
        }



        /* ========================================
           구현 순서 11: 댓글 작성 (POST 요청)
           ======================================== */

        /*
            11. 댓글 작성 함수
                - POST /api/comments/boards/{boardId} 호출
                - 성공 시 댓글 목록 새로고침 및 입력 필드 초기화
        */
        function createComment() {
            // 11-1. 입력된 댓글 내용 가져오기 및 공백 제거
            const content = document.getElementById('commentContent').value.trim();

            // 11-2. 입력 검증: 빈 문자열 체크
            if (!content) {
                alert('댓글 내용을 입력해주세요.');
                return;  // 함수 종료
            }

            // 11-3. REST API 호출 (POST 요청)
            fetch(`/api/comments/boards/${boardId}`, {
                method: 'POST',  // HTTP POST 메서드
                headers: {
                    'Content-Type': 'application/json',  // 11-4. JSON 형식으로 전송
                    [csrfHeader]: csrfToken  // 11-5. CSRF 토큰을 요청 헤더에 추가
                },
                body: JSON.stringify({ content: content })  // 11-6. 댓글 내용을 JSON으로 변환
            })
            .then(response => {
                // 11-7. HTTP 상태 코드 확인
                if (!response.ok) {  // HTTP 상태 코드가 200번대가 아니면
                    return response.json().then(err => {
                        throw new Error(err.message || '댓글 작성에 실패했습니다.');
                    });
                }
                return response.json();  // 11-8. 성공 시 JSON 응답 파싱 (HTTP 201 Created + CommentDTO)
            })
            .then(comment => {  // 11-9. 생성된 댓글 객체 받기
                document.getElementById('commentContent').value = '';  // 11-10. 입력 필드 초기화
                loadComments();  // 11-11. 댓글 목록 새로고침
                alert('댓글이 작성되었습니다.');
            })
            .catch(error => {  // 11-12. 에러 발생 시 처리
                console.error('댓글 작성 실패:', error);
                alert(error.message);
            });
        }




        /* ========================================
           구현 순서 12: 댓글 수정 모드 활성화
           ======================================== */

        /*
            12. 댓글 수정 모드 활성화 함수
                - 댓글 내용을 textarea로 변경하여 수정 가능하게 함
        */
        function editComment(commentId) {
            // 12-1. 해당 댓글의 내용 영역 가져오기
            const contentElement = document.getElementById(`comment-content-${commentId}`);
            const currentContent = contentElement.textContent.trim();  // 12-2. 현재 댓글 내용 (공백 제거)

            // 12-3. 댓글 내용을 textarea로 변경 - 수정 가능한 폼으로 전환
            contentElement.innerHTML = `
                <div class="comment-edit-form">
                    <!-- 12-3-1. 수정용 textarea: 고유 ID로 식별, 현재 내용을 XSS 방지 처리하여 표시 -->
                    <textarea id="edit-textarea-${commentId}" rows="3">${escapeHtml(currentContent)}</textarea>
                    <div class="comment-edit-actions">
                        <!-- 12-3-2. 저장 버튼: 클릭 시 saveComment() 함수 호출하여 수정 내용 서버에 전송 -->
                        <button class="comment-save-btn" onclick="saveComment(${commentId})">
                            <i class="fas fa-check"></i> 저장
                        </button>
                        <!-- 12-3-3. 취소 버튼: 클릭 시 cancelEdit() 함수 호출하여 원래 내용으로 복원 -->
                        <!--          작은따옴표는 이스케이프 처리하여 JavaScript 문자열 충돌 방지 -->
                        <button class="comment-cancel-btn" onclick="cancelEdit(${commentId}, '${escapeHtml(currentContent).replace(/'/g, "\\'")}')">
                            <i class="fas fa-times"></i> 취소
                        </button>
                    </div>
                </div>
            `;
        }



        /* ========================================
           구현 순서 13: 댓글 수정 저장 (PUT 요청)
           ======================================== */

        /*
            13. 댓글 수정 저장 함수
                - PUT /api/comments/{commentId} 호출
                - 성공 시 댓글 목록 새로고침
        */
        function saveComment(commentId) {
            // 13-1. 수정된 내용 가져오기
            const content = document.getElementById(`edit-textarea-${commentId}`).value.trim();

            // 13-2. 입력 검증
            if (!content) {
                alert('댓글 내용을 입력해주세요.');
                return;
            }

            // 13-3. REST API 호출 (PUT 요청)
            fetch(`/api/comments/${commentId}`, {
                method: 'PUT',  // HTTP PUT 메서드
                headers: {
                    'Content-Type': 'application/json',  // 13-4. JSON 형식으로 전송
                    [csrfHeader]: csrfToken  // 13-5. CSRF 토큰을 요청 헤더에 추가
                },
                body: JSON.stringify({ content: content })  // 13-6. 수정된 내용을 JSON으로 변환
            })
            .then(response => {
                // 13-7. HTTP 상태 코드 확인
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.message || '댓글 수정에 실패했습니다.');
                    });
                }
                return response.json();  // 13-8. 성공 시 JSON 응답 파싱 (HTTP 200 OK + CommentDTO)
            })
            .then(comment => {  // 13-9. 수정된 댓글 객체 받기
                loadComments();  // 13-10. 댓글 목록 새로고침
                alert('댓글이 수정되었습니다.');
            })
            .catch(error => {  // 13-11. 에러 발생 시 처리
                console.error('댓글 수정 실패:', error);
                alert(error.message);
            });
        }



        /* ========================================
           구현 순서 14: 댓글 수정 취소
           ======================================== */

        /*
            14. 댓글 수정 취소 함수
                - textarea를 원래 텍스트로 되돌림
        */
        function cancelEdit(commentId, originalContent) {
            // 14-1. 댓글 내용 영역 가져오기
            const contentElement = document.getElementById(`comment-content-${commentId}`);
            // 14-2. 원래 내용으로 복원
            contentElement.innerHTML = originalContent;
        }



        /* ========================================
           구현 순서 15: 댓글 삭제 (DELETE 요청)
           ======================================== */

        /*
            15. 댓글 삭제 함수
                - DELETE /api/comments/{commentId} 호출
                - 성공 시 댓글 목록 새로고침
        */
        function deleteComment(commentId) {
            // 15-1. 삭제 확인 대화상자 표시
            if (!confirm('정말 이 댓글을 삭제하시겠습니까?')) {
                return;  // 취소하면 함수 종료
            }

            // 15-2. REST API 호출 (DELETE 요청)
            fetch(`/api/comments/${commentId}`, {
                method: 'DELETE',  // HTTP DELETE 메서드
                headers: {
                    [csrfHeader]: csrfToken  // 15-3. CSRF 토큰만 필요 (Content-Type 불필요)
                }
                // 15-4. DELETE 요청은 본문(body)이 없음
            })
            .then(response => {
                // 15-5. HTTP 상태 코드 확인
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.message || '댓글 삭제에 실패했습니다.');
                    });
                }
                // 15-6. DELETE 성공 (HTTP 204 No Content)
                //       204 응답은 본문이 없으므로 response.json() 호출하지 않음
                loadComments();  // 15-7. 댓글 목록 새로고침
                alert('댓글이 삭제되었습니다.');
            })
            .catch(error => {  // 15-8. 에러 발생 시 처리
                console.error('댓글 삭제 실패:', error);
                alert(error.message);
            });
        }



        /* ========================================
           구현 순서 16: HTML 이스케이프 함수 (XSS 방지)
           ======================================== */

        /*
            16. HTML 이스케이프 함수 (XSS 방지)
                - 사용자 입력을 HTML에 안전하게 표시하기 위해 특수문자 변환
        */
        function escapeHtml(text) {
            // 16-1. HTML 특수문자를 안전한 HTML 엔티티로 변환하는 매핑 객체
            const map = {
                '&': '&amp;',    // & 기호 → &amp; (가장 먼저 변환해야 다른 엔티티가 중복 변환되지 않음)
                '<': '&lt;',     // < 기호 → &lt; (HTML 태그 시작 방지)
                '>': '&gt;',     // > 기호 → &gt; (HTML 태그 종료 방지)
                '"': '&quot;',   // 큰따옴표 → &quot; (속성값 이스케이프)
                "'": '&#039;'    // 작은따옴표 → &#039; (속성값 이스케이프)
            };

            // 16-2. 정규식으로 특수문자 찾아서 매핑 객체의 값으로 치환
            //       /[&<>"']/g : 정규식 패턴
            //         [ ] : 문자 클래스 (괄호 안의 문자 중 하나와 매칭)
            //         &<>"' : 찾을 특수문자들 (앰퍼샌드, 꺾쇠괄호, 따옴표)
            //         g : global 플래그 (문자열 전체에서 모든 일치 항목 찾기)
            //       m => map[m] : 매칭된 문자(m)를 map 객체의 값으로 치환하는 콜백 함수
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        /* ========================================
           좋아요 기능 JavaScript
           ======================================== */

        // 페이지 로드 시 좋아요 버튼 이벤트 리스너 등록 (DOMContentLoaded에 추가)
        const likeButton = document.getElementById('likeButton');
        if (likeButton) {
            likeButton.addEventListener('click', toggleLike);
        }

        /**
         * 좋아요 토글 함수
         * - POST /api/boards/{boardId}/like 호출
         * - 성공 시 버튼 상태 및 좋아요 수 업데이트
         */
        function toggleLike() {
            const likeButton = document.getElementById('likeButton');
            const boardId = likeButton.dataset.boardId;  // data-board-id 값 가져오기

            // REST API 호출
            fetch(`/api/boards/${boardId}/like`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    [csrfHeader]: csrfToken
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('좋아요 처리 실패');
                }
                return response.json();
            })
            .then(data => {
                // 서버 응답: { liked: true/false, likeCount: 숫자 }
                updateLikeButton(data.liked, data.likeCount);
            })
            .catch(error => {
                console.error('좋아요 오류:', error);
                alert('좋아요 처리 중 오류가 발생했습니다.');
            });
        }

        /**
         * 좋아요 버튼 UI 업데이트 함수
         * @param {boolean} liked - 좋아요 상태 (true: 좋아요, false: 취소)
         * @param {number} likeCount - 좋아요 총 개수
         */
        function updateLikeButton(liked, likeCount) {
            const likeButton = document.getElementById('likeButton');
            const heartIcon = likeButton.querySelector('i');
            const likeCountSpan = document.getElementById('likeCount');

            // 좋아요 수 업데이트
            likeCountSpan.textContent = likeCount;

            // 버튼 상태 업데이트
            if (liked) {
                // 좋아요 누른 상태
                likeButton.classList.add('liked');
                likeButton.dataset.liked = 'true';
                heartIcon.className = 'fas fa-heart';  // 꽉 찬 하트
            } else {
                // 좋아요 취소 상태
                likeButton.classList.remove('liked');
                likeButton.dataset.liked = 'false';
                heartIcon.className = 'far fa-heart';  // 빈 하트
            }
        }

        /*
            게시글 삭제 함수
                - 사용자에게 삭제 확인을 받은 후 DELETE 요청을 보냄
                - HTML form을 동적으로 생성하여 제출 (DELETE 메서드 지원)
        */
        function deleteBoard() {
            //1)사용자에게 삭제 확인
            if (!confirm('정말 이 게시글을 삭제하시겠습니까?\n삭제된 게시글을 복구할수 없습니다.')) {
                return;     //취소하면 함수 종료
            }

            /*
                2) Thymeleaf로 게시글 ID 가져오기
                - [[ ${expression} ]] : Thymeleaf 인라인 표현식 - 서버 변수를 JS변수로 변환
            */
            const boardId = [[${board.id}]];

            /*
                3) HTML form 동적 생성
                    - JavaScript로 form 요소를 동적으로 생성
                    - 삭제 요청을 서버로 전송하기 위한 form
            */
            const form = document.createElement('form');     // <form> 태그 생성
            form.method = 'POST';   // HTTP POST 메서드 (브라우저는 form으로 DELETE를 직접 못 보냄)
            form.action = `/boards/${boardId}`;     // 요청 URL: /boards/123 (게시글 ID 포함)

            /*
                4) Spring이 DELETE로 인식
                    - _method 필드 추가
                        - 브라우저는 form으로 DELETE 메서드를 직접 보낼수 없음
                        - POST로 보내고 _method=DELETE로 Spring에게 알려줌
                        - Spring의 HiddenHttpMethodFilter가 이를 감지하여 DELETE로 변환
            */
            const methodInput = document.createElement('input');
            methodInput.type = 'hidden';        // 화면에 보이지 않는 hidden 필드
            methodInput.name = '_method';       // Spring이 인식하는 필드 이름
            methodInput.value = 'DELETE';       // HTTP DELETE 메서드 지정
            form.appendChild(methodInput);      // form에 필드 추가

            /*
                5) CSRF 토큰 추가 (Spring Security 보안)
                    - layout.html의 메타 태그에서 CSRF 토큰 읽기
                    - Spring Security가 요청 시 자동 검증
            */
            const csrfToken = document.querySelector('meta[name="_csrf"]').content;  // CSRF 토큰 값
            const csrfHeader = document.querySelector('meta[name="_csrf_header"]').content;  // CSRF 헤더 이름

            // CSRF 토큰을 hidden input으로 form에 추가
            const csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = '_csrf';   // Spring Security가 인식하는 파라미터 이름
            csrfInput.value = csrfToken;    //실제 토큰 값
            form.appendChild(csrfInput);    //form에 필드 추가

            // 6) form을 body에 추가하고 제출
            document.body.appendChild(form);
            form.submit();
        }
        /*]]>*/
    </script>
</th:block>
</body>
</html>